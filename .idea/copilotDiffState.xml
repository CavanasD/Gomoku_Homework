<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/widget/aibrain.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/widget/aibrain.h" />
              <option name="originalContent" value="//&#10;// Created by CavanasD on 2025/10/6.&#10;//&#10;&#10;#ifndef MY_APP_AIBRAIN_H&#10;#define MY_APP_AIBRAIN_H&#10;&#10;#include &lt;utility&gt;&#10;&#10;class AIBrain {&#10;public:&#10;    virtual ~AIBrain() = default;&#10;&#10;    // Given a 15x15 board (0 empty, 1 black, 2 white), return best move (x,y)&#10;    // Implementations should return {-1,-1} if no move available.&#10;    virtual std::pair&lt;int,int&gt; getBestMove(const int (*board)[15]) = 0;&#10;};&#10;&#10;#endif // MY_APP_AIBRAIN_H&#10;" />
              <option name="updatedContent" value="//&#10;// Created by CavanasD on 2025/10/6.&#10;//&#10;&#10;#ifndef MY_APP_AIBRAIN_H&#10;#define MY_APP_AIBRAIN_H&#10;&#10;#include &lt;utility&gt;&#10;&#10;class AIBrain {&#10;public:&#10;    virtual ~AIBrain() = default;&#10;&#10;    // Given a 15x15 board (0 empty, 1 black, 2 white), return best move (x,y)&#10;    // Implementations should return {-1,-1} if no move available.&#10;    virtual std::pair&lt;int,int&gt; getBestMove(const int (*board)[15]) = 0;&#10;};&#10;&#10;class MCTSBrain : public AIBrain {&#10;public:&#10;    // timeLimitMs: 单次搜索时间上限（毫秒）；maxIterations: 单次搜索最大迭代数；&#10;    // explorationC: UCT 探索系数；useNeighborhood: 只在已有棋子邻域内展开；neighborhoodRadius: 邻域半径。&#10;    explicit MCTSBrain(int timeLimitMs = 200,&#10;                       int maxIterations = 10000,&#10;                       double explorationC = 1.41421356237,&#10;                       bool useNeighborhood = true,&#10;                       int neighborhoodRadius = 2);&#10;&#10;    ~MCTSBrain() override = default;&#10;&#10;    std::pair&lt;int,int&gt; getBestMove(const int (*board)[15]) override;&#10;&#10;private:&#10;    int timeLimitMs_;&#10;    int maxIterations_;&#10;    double c_;&#10;    bool useNeighborhood_;&#10;    int neighborhoodRadius_;&#10;};&#10;&#10;#endif // MY_APP_AIBRAIN_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/widget/gamewindow.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/widget/gamewindow.h" />
              <option name="originalContent" value="#ifndef MY_APP_GAMEWINDOW_H&#10;#define MY_APP_GAMEWINDOW_H&#10;&#10;#include &lt;QWidget&gt;&#10;#include &quot;gomokuLogic.h&quot;&#10;&#10;QT_BEGIN_NAMESPACE&#10;&#10;namespace Ui {&#10;    class gameWindow;&#10;}&#10;&#10;QT_END_NAMESPACE&#10;&#10;class gameWindow : public QWidget {&#10;    Q_OBJECT&#10;public:&#10;    explicit gameWindow(QWidget *parent = nullptr);&#10;    ~gameWindow() override;&#10;&#10;private slots:&#10;    void on_backToMain_clicked();&#10;    void on_startBut_clicked();&#10;    void on_resetBut_clicked();&#10;&#10;    // New: handle click from ChessBoard&#10;    void handleBoardClick(int x, int y);&#10;&#10;private:&#10;    void updateTurnLabel() const;&#10;&#10;    Ui::gameWindow *ui;&#10;&#10;    // Game state manager&#10;    GomokuLogic logic;&#10;    bool gameActive{false};&#10;&#10;&#10;#endif //MY_APP_GAMEWINDOW_H" />
              <option name="updatedContent" value="#ifndef MY_APP_GAMEWINDOW_H&#10;#define MY_APP_GAMEWINDOW_H&#10;&#10;#include &lt;QWidget&gt;&#10;#include &lt;memory&gt;&#10;#include &quot;gomokuLogic.h&quot;&#10;#include &quot;aibrain.h&quot;  // 直接包含，避免不完整类型问题&#10;&#10;QT_BEGIN_NAMESPACE&#10;&#10;namespace Ui {&#10;    class gameWindow;&#10;}&#10;&#10;QT_END_NAMESPACE&#10;&#10;class gameWindow : public QWidget {&#10;    Q_OBJECT&#10;public:&#10;    explicit gameWindow(QWidget *parent = nullptr);&#10;    // 新增：支持指定是否为人机模式，以及 AI 扮演的阵营（默认白棋）&#10;    explicit gameWindow(bool vsAI, GomokuLogic::Player aiSide = GomokuLogic::White, QWidget *parent = nullptr);&#10;    ~gameWindow() override;&#10;&#10;private slots:&#10;    void on_backToMain_clicked();&#10;    void on_startBut_clicked();&#10;    void on_resetBut_clicked();&#10;&#10;    // New: handle click from ChessBoard&#10;    void handleBoardClick(int x, int y);&#10;&#10;private:&#10;    void updateTurnLabel() const;&#10;    // 新增：触发 AI 思考并落子&#10;    void triggerAIMove();&#10;&#10;    Ui::gameWindow *ui;&#10;&#10;    // Game state manager&#10;    GomokuLogic logic;&#10;&#10;    bool gameActive{false};&#10;&#10;    // 新增：人机模式与 AI 侧&#10;    bool vsAI{false};&#10;    GomokuLogic::Player aiSide{GomokuLogic::White};&#10;    bool aiThinking{false};&#10;&#10;    std::unique_ptr&lt;AIBrain&gt; aiBrain;&#10;};&#10;&#10;#endif //MY_APP_GAMEWINDOW_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/widget/gomoku.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/widget/gomoku.cpp" />
              <option name="originalContent" value="#include &quot;gomoku.h&quot;&#10;#include &quot;ui_Gomoku.h&quot;&#10;#include &quot;ui_gamewindow.h&quot;&#10;#include &quot;gameWindow.h&quot;&#10;Gomoku::Gomoku(QWidget *parent) : QWidget(parent), ui(new Ui::Gomoku) {&#10;    ui-&gt;setupUi(this);&#10;}&#10;&#10;Gomoku::~Gomoku() {&#10;    delete ui;&#10;}&#10;&#10;void Gomoku::on_vsAIBut_clicked() {&#10;    this-&gt;close();&#10;    auto *gw = new gameWindow();&#10;    gw-&gt;setAttribute(Qt::WA_DeleteOnClose);&#10;    gw-&gt;show();&#10;}&#10;void Gomoku::on_pvpBut_clicked() {&#10;    this-&gt;close();&#10;    auto *gw = new gameWindow();&#10;    gw-&gt;setAttribute(Qt::WA_DeleteOnClose);&#10;    gw-&gt;show();&#10;}&#10;void Gomoku::on_exitBut_clicked() {&#10;    QApplication::quit();&#10;}" />
              <option name="updatedContent" value="#include &quot;gomoku.h&quot;&#10;#include &quot;ui_Gomoku.h&quot;&#10;#include &quot;ui_gamewindow.h&quot;&#10;#include &quot;gameWindow.h&quot;&#10;Gomoku::Gomoku(QWidget *parent) : QWidget(parent), ui(new Ui::Gomoku) {&#10;    ui-&gt;setupUi(this);&#10;}&#10;&#10;Gomoku::~Gomoku() {&#10;    delete ui;&#10;}&#10;&#10;void Gomoku::on_vsAIBut_clicked() {&#10;    this-&gt;close();&#10;    // 人机模式：默认让 AI 扮演白棋（玩家先手）&#10;    auto *gw = new gameWindow(true, GomokuLogic::White);&#10;    gw-&gt;setAttribute(Qt::WA_DeleteOnClose);&#10;    gw-&gt;show();&#10;}&#10;void Gomoku::on_pvpBut_clicked() {&#10;    this-&gt;close();&#10;    // 人人模式：不启用 AI&#10;    auto *gw = new gameWindow(false);&#10;    gw-&gt;setAttribute(Qt::WA_DeleteOnClose);&#10;    gw-&gt;show();&#10;}&#10;void Gomoku::on_exitBut_clicked() {&#10;    QApplication::quit();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>